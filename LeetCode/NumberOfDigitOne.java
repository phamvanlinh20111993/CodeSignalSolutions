package LeetCode;

/**
 * url: https://leetcode.com/problems/number-of-digit-one/description/
 * Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.

 

Example 1:

Input: n = 13
Output: 6
Example 2:

Input: n = 0
Output: 0
 

Constraints:

0 <= n <= 109
 */
public class NumberOfDigitOne {
	/**
    formula base on example

    1. 12467

    => 1abcd = 2467 + 1(10000) = 2468
    => a1bcd = 10^3 = 1000
    => ab1cd = [1(0-1)1(0-9)(0-9)] + [121(0-9)(0-9)]               = 2*10*10 + 10*10 = 300 
    => abc1d = [1(0-1)(0-9)1(0-9)] + [12(0-3)1(0-9)] + [1241(0-9)] = 2*10*10 + 4*10 + 10  = 250
    => abcd1 = [1(0-1)(0-9)(0-9)1] + [12(0-3)(0-9)1] + [124(0-6)1] = 200 + 4*10 + 7 = 247
    ==> (2468 + 1000 + 300 + 250 + 247) + [1-9999] = 4265 + 4000 = 8265     /8265


    2. 36738

    => 1abcd = 10^4 = 10000
       a1bcd = [(1-2)1(0-9)(0-9)(0-9)] + [31(0-9)(0-9)(0-9)] = 2*10*10*10 + 10^3 = 3000
       ab1cd = [(1-2)(0-9)1(0-9)(0-9)] + [3(0-5)1(0-9)(0-9)] + [361(0-9)(0-9)] = 2*10*10*10 + 6*10*10 + 10*10 = 2700
       abc1d = [(1-2)(0-9)(0-9)1(0-9)] + [3(0-5)(0-9)1(0-9)] + [36(0-6)1(0-9)] + [3671(0-9)] = 2000 + 600 + 70 + 10 = 2770
       abcd1 = [(1-2)(0-9)(0-9)(0-9)1] + [3(0-5)(0-9)(0-9)1] + [36(0-6)(0-9)1] + [367(0-3)1] = 2000 + 600 + 70 + 4 = 2674
    ==> (10000 + 3000 + 2700 + 2770 + 2674) + [1-9999] = 25054           /25054


    3. 5113

    => 1abc = 10^3 = 1000
       a1bc = [(1-4)1(0-9)(0-9)] + [51(0)(0-9)] + [511(0-3)] = 4*10*10 + 10 + 4 = 414
       ab1c = [(1-4)(0-9)1(0-9)] + [5(0)1(0-9)] + [511(0-3)] = 4*10*10 + 10 + 4 = 414
       abc1 = [(1-4)(0-9)(0-9)1] + [5(0)(0-9)1] + [51(0-1)1] = 4*10*10 + 10 + 2 = 412
    ==> (1000 + 414 + 414 + 412) + [1-999] = 2240 + 300 = 2540             /2540


    ....


    abcdef, l = 6

    1bcdef -> if a > 1  <=> 10^5
                 a == 1 <=> 1 + bcdef 

    a1cdef -> (a-1)*10^(l-2) +  - if(b > 1)  10^4(l-2)
                                - if(b == 1) cdef + 1

    ab1def -> (a-1)*10^(l-2) + b*10^(l-3) +     - if(c > 1)  10^(l-3)						
                                                - if(c == 1) def+1
                                    
    abc1ef -> (a-1)*10^(l-2) + b*10^(l-3) + c*10^(l-4) + - if(d > 1)   10^(l-4)
                                                         - if(d == 1)  f + 1				
                                            
    .....	
    abcde1 -> (a-1)*10^(l-2) + b*10^(l-3) + c*10^(l-4) + d*10^(l-5) + (e+1) 						
            
            
    abcd = 4453
    1bcd -> a = 4 > 1 => 10^3                                 1000
    a1cd -> 3*10^2 + (b = 4 > 1) 10^2                         400   
    ab1d ->  3*10^2 + 4*10  + 10                              350
    abc1 ->  3*10^2 + 4*10 + 6                                346

    => (1000+400+350+346)+300 = 2396
    
    
    abcd = 5113, l = 4
    1bcd -> a = 5 > 1 => 10^3 = 1000
    a1cd -> 4*10^2 + (b = 1) => 13+1 = 14+400 = 414
    ab1d -> 4*10^2 + 1*10 + 4 => 400 + 10 + 4 = 414
    abc1 -> 4*10^2 + 1*10 + (1+1) => 400 + 10 + 2 = 412

    => (1000+414+414+412)+300 =  2240 + 300 = 2540  



    abcde = 12467, l = 5
    1bcde -> a = 1 => 2467 + 1 = 2468
    a1cde -> 0*10^3 + (b = 2 > 1) 10^3 = 1000
    ab1de -> 0*10^3 + 2*10^2 + (c = 4 > 1) 10^2 = 300
    abc1e -> 0*10^3 + 2*10^2 + 4*10 + (d = 6 > 1) + 10 = 250
    abcd1 -> 0*10^3 + 2*10^2 + 4*10 + (6+1) = 247

    => (2468 + 1000 + 300 + 250 + 247) + [1-9999] = 4265 + 4000 = 8265     
 */ 

	public int toInt(char[] cNum, int ind) {
		int res = 0, l = cNum.length;
		for (int i = ind; i < cNum.length; i++) {
			res += (cNum[i] - '0') * Math.pow(10, l - i - 1);
		}
		return res;
	}

	public int countDigitOne(int n) {
		char[] num = (n + "").toCharArray();
		int l = num.length;
		int res = (l - 1) * (int) Math.pow(10, l - 2);

		for (int i = 0; i < num.length; i++) {
			int j = 0;
			int tmp = 0;
			while (j < i) {
				if (j == 0)
					tmp += (num[j] - '0' - 1) * Math.pow(10, l - j - 2);
				else
					tmp += (num[j] - '0') * Math.pow(10, l - j - 2);
				j++;
			}
			if (num[j] - '0' > 1) {
				tmp += Math.pow(10, l - i - 1);
			} else if (num[j] - '0' == 1) {
				tmp += toInt(num, j + 1) + 1;
			}

			res += tmp;
		}

		return res;
	}

	public static void main(String[] args) {
		

	}

}
